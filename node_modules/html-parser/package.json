{
  "name": "html-parser",
  "version": "0.10.0",
  "description": "HTML/XML parser with less explosions",
  "keywords": [
    "html",
    "xml",
    "parser",
    "explosion"
  ],
  "author": {
    "name": "Tommy Montgomery",
    "email": "tmont@tmont.com",
    "url": "http://tmont.com/"
  },
  "license": "MIT",
  "contributors": [
    {
      "name": "jdponomarev"
    },
    {
      "name": "fiatjaf"
    },
    {
      "name": "Sergii Kliuchnyk"
    }
  ],
  "main": "./src/parser.js",
  "files": [
    "src"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/tmont/html-parser.git"
  },
  "devDependencies": {
    "mocha": "2.5.3",
    "should": "8.2.2"
  },
  "scripts": {
    "test": "node_modules/.bin/mocha -R dot ./tests"
  },
  "readme": "# html-parser\n\n[![Build Status](https://travis-ci.org/tmont/html-parser.png)](https://travis-ci.org/tmont/html-parser)\n[![NPM version](https://badge.fury.io/js/html-parser.png)](http://badge.fury.io/js/html-parser)\n\nNow with less explosions!\n\nThe purpose of this library is not to be the best XML parsing library ever\nconceived. Because it's not. It's meant to be an HTML/XML parser that doesn't\nrequire valid HTML/XML. It's also meant to act as a sanitizer, which is the\nmain reason for it's existence.\n\nFor example, you can just shove a blob of text into it, and it will happily\nparse as if it were valid XML.\n\nLicensed under [MIT](./LICENSE).\n\n## Installation\n`npm install html-parser`\n\n## Callback based parsing\n```javascript\nvar htmlParser = require('html-parser');\n\nvar html = '<!doctype html><html><body onload=\"alert(\\'hello\\');\">Hello<br />world</body></html>';\nhtmlParser.parse(html, {\n\topenElement: function(name) { console.log('open: %s', name); },\n\tcloseOpenedElement: function(name, token, unary) { console.log('token: %s, unary: %s', token, unary); },\n\tcloseElement: function(name) { console.log('close: %s', name); },\n\tcomment: function(value) { console.log('comment: %s', value); },\n\tcdata: function(value) { console.log('cdata: %s', value); },\n\tattribute: function(name, value) { console.log('attribute: %s=%s', name, value); },\n\tdocType: function(value) { console.log('doctype: %s', value); },\n\ttext: function(value) { console.log('text: %s', value); }\n});\n\n/*\ndoctype: html\nopen: html\nclose token: >\nopen: body\nattribute: onload=alert('hello');\nclose token: >\ntext: Hello\nopen: br\nclose token: />, unary: true\ntext: world\nclose: body\nclose: html\n*/\n```\n\n## Sanitization\n```javascript\nvar htmlParser = require('html-parser');\n\nvar html = '<script>alert(\\'danger!\\')</script><p onclick=\"alert(\\'danger!\\')\">blah blah<!-- useless comment --></p>';\nvar sanitized = htmlParser.sanitize(html, {\n\telements: [ 'script' ],\n\tattributes: [ 'onclick' ],\n\tcomments: true\n});\n\nconsole.log(sanitized);\n//<p>blah blah</p>\n```\n\n### Using callbacks\n```javascript\nvar htmlParser = require('html-parser');\n\nvar html = '<script>alert(\\'danger!\\')</script><p onclick=\"alert(\\'danger!\\')\">blah blah<!-- useless comment --></p>';\nvar sanitized = htmlParser.sanitize(html, {\n\telements: function(name) {\n\t\treturn name === 'script';\n\t},\n\tattributes: function(name, value) {\n\t\treturn /^on/i.test(name) || /^javascript:/i.test(value);\n\t},\n\tcomments: true\n});\n\nconsole.log(sanitized);\n//<p>blah blah</p>\n```\n\n### Custom data elements\nYou can parser custom data elements like php code or underscore templates with `regex.dataElements` config\n```javascript\nhelpers.parseString('<div><?= \"<div>$var</div>\" ?></div>', {\n    openElement: function(name) {\n        console.log(name); // 'div'\n    },\n    closeElement: function(name) {\n        console.log(name); // 'div'\n    },\n    phpEcho: function(value) {\n        console.log(value); // {length: 61, someProperty: ' \"<div>$var</div>\" '}\n    }\n}, {\n    dataElements: {\n        phpEcho: {\n            start: '<?=',\n            data: function (string) {\n                var index = string.indexOf('?>'),\n                    code = string.slice(0, index);\n\n                return code;\n                // or\n                return {\n                    length: code.length, // required field\n                    someProperty: code\n                };\n            },\n            end: '?>'\n        }\n    }\n});\n```\n\n## API\n```javascript\n/**\n * Parses the given string o' HTML, executing each callback when it\n * encounters a token.\n *\n * @param {String} htmlString A string o' HTML\n * @param {Object} [callbacks] Callbacks for each token\n * @param {Function} [callbacks.attribute] Takes the name of the attribute and its value\n * @param {Function} [callbacks.openElement] Takes the tag name of the element\n * @param {Function} [callbacks.closeOpenedElement] Takes the tag name of the element and the token used to\n * close it (\">\", \"/>\", \"?>\")\n * @param {Function} [callbacks.closeElement] Takes the name of the element\n * @param {Function} [callbacks.comment] Takes the content of the comment\n * @param {Function} [callbacks.docType] Takes the content of the document type declaration\n * @param {Function} [callbacks.cdata] Takes the content of the CDATA\n * @param {Function} [callbacks.xmlProlog] Takes no arguments\n * @param {Function} [callbacks.text] Takes the value of the text node\n * @param {Object} [regex]\n * @param {RegExp} [regex.name] Regex for element name. Default is [a-zA-Z_][\\w:\\-\\.]*\n * @param {RegExp} [regex.attribute] Regex for attribute name. Default is [a-zA-Z_][\\w:\\-\\.]*\n * @param {Object.<callbackName,DataElementConfig>} [regex.dataElements] Config of data elements like docType, comment and your own custom data elements\n */\nparse(htmlString, callbacks, regex)\n\n/**\n * @typedef {Object} DataElementConfig\n * @property {String|RegExp|Function} start - start of data element, for example '<%' or /^<\\?=/ or function(string){return string.slice(0, 2) === '<%' ? 2 : -1;}\n * @property {RegExp|Function} data - content of data element, for example /^[^\\s]+/ or function(string){return string.match(/^[^\\s]+/)[0];}\n * @property {String|RegExp|Function} end - end of data element, for example '%>' or /^\\?>/ or function(string){return 2;}\n */\n\n/**\n * Parses the HTML contained in the given file asynchronously.\n *\n * Note that this is merely a convenience function, it will still read the entire\n * contents of the file into memory.\n *\n * @param {String} fileName Name of the file to parse\n * @param {String} [encoding] Optional encoding to read the file in, defaults to utf8\n * @param {Object} [callbacks] Callbacks to pass to parse()\n * @param {Function} [callback]\n */\nparseFile(fileName, encoding, callbacks, callback)\n\n/**\n * Sanitizes an HTML string.\n *\n * If removalCallbacks is not given, it will simply reformat the HTML\n * (i.e. converting all tags to lowercase, etc.). Note that this function\n * assumes that the HTML is decently formatted and kind of valid. It\n * may exhibit undefined or unexpected behavior if your HTML is trash.\n *\n * @param {String} htmlString A string o' HTML\n * @param {Object} [removalCallbacks] Callbacks for each token type\n * @param {Function|Array} [removalCallbacks.attributes] Callback or array of specific attributes to strip\n * @param {Function|Array} [removalCallbacks.elements] Callback or array of specific elements to strip\n * @param {Function|Boolean} [removalCallbacks.comments] Callback or boolean indicating to strip comments\n * @param {Function|Boolean} [removalCallbacks.docTypes] Callback or boolean indicating to strip doc type declarations\n * @return {String} The sanitized HTML\n */\nsanitize(htmlString, removalCallbacks)\n```\n\n## Development\n```shell\ngit clone https://github.com/tmont/html-parser.git\ncd html-parser\nnpm link\nnpm test\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/tmont/html-parser/issues"
  },
  "_id": "html-parser@0.10.0",
  "dist": {
    "shasum": "4ea7f17957cdd58d7ee06f2f6cdc2ddd5b9d8a5e"
  },
  "_from": "html-parser@",
  "_resolved": "https://registry.npmjs.org/html-parser/-/html-parser-0.10.0.tgz"
}
